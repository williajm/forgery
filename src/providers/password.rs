//! Password generation provider.
//!
//! Generates random passwords with configurable character sets and length.

use crate::rng::ForgeryRng;

/// Lowercase letters.
const LOWERCASE: &[u8] = b"abcdefghijklmnopqrstuvwxyz";

/// Uppercase letters.
const UPPERCASE: &[u8] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ";

/// Digits.
const DIGITS: &[u8] = b"0123456789";

/// Common symbols.
const SYMBOLS: &[u8] = b"!@#$%^&*()-_=+[]{}|;:,.<>?";

/// Generate a batch of passwords.
///
/// Each password is guaranteed to contain at least one character from each
/// enabled character set (if the length permits).
///
/// # Arguments
///
/// * `rng` - The random number generator to use
/// * `n` - Number of passwords to generate
/// * `length` - Length of each password
/// * `uppercase` - Include uppercase letters
/// * `lowercase` - Include lowercase letters
/// * `digits` - Include digits
/// * `symbols` - Include symbols
///
/// # Returns
///
/// A vector of random passwords, or an error if no character sets are enabled
/// or if the length is too short to include all required character sets.
///
/// # Note
///
/// This generates fake data for testing purposes. The RNG is deterministic
/// and seedable, so passwords generated by this function should NOT be used
/// for security-sensitive applications.
pub fn generate_passwords(
    rng: &mut ForgeryRng,
    n: usize,
    length: usize,
    uppercase: bool,
    lowercase: bool,
    digits: bool,
    symbols: bool,
) -> Result<Vec<String>, PasswordError> {
    // Build the character sets info
    let charsets = build_charsets(uppercase, lowercase, digits, symbols)?;

    // Check that length is sufficient
    if length < charsets.len() {
        return Err(PasswordError::LengthTooShort {
            length,
            required: charsets.len(),
        });
    }

    let pool = build_char_pool(uppercase, lowercase, digits, symbols)?;

    let mut passwords = Vec::with_capacity(n);
    for _ in 0..n {
        passwords.push(generate_password_with_guarantee(rng, length, &pool, &charsets));
    }
    Ok(passwords)
}

/// Generate a single password.
///
/// The password is guaranteed to contain at least one character from each
/// enabled character set (if the length permits).
///
/// # Arguments
///
/// * `rng` - The random number generator to use
/// * `length` - Length of the password
/// * `uppercase` - Include uppercase letters
/// * `lowercase` - Include lowercase letters
/// * `digits` - Include digits
/// * `symbols` - Include symbols
///
/// # Returns
///
/// A random password, or an error if no character sets are enabled
/// or if the length is too short to include all required character sets.
///
/// # Note
///
/// This generates fake data for testing purposes. The RNG is deterministic
/// and seedable, so passwords generated by this function should NOT be used
/// for security-sensitive applications.
#[inline]
pub fn generate_password(
    rng: &mut ForgeryRng,
    length: usize,
    uppercase: bool,
    lowercase: bool,
    digits: bool,
    symbols: bool,
) -> Result<String, PasswordError> {
    let charsets = build_charsets(uppercase, lowercase, digits, symbols)?;

    if length < charsets.len() {
        return Err(PasswordError::LengthTooShort {
            length,
            required: charsets.len(),
        });
    }

    let pool = build_char_pool(uppercase, lowercase, digits, symbols)?;
    Ok(generate_password_with_guarantee(rng, length, &pool, &charsets))
}

/// Build a list of enabled character sets.
fn build_charsets(
    uppercase: bool,
    lowercase: bool,
    digits: bool,
    symbols: bool,
) -> Result<Vec<&'static [u8]>, PasswordError> {
    let mut charsets = Vec::with_capacity(4);

    if lowercase {
        charsets.push(LOWERCASE);
    }
    if uppercase {
        charsets.push(UPPERCASE);
    }
    if digits {
        charsets.push(DIGITS);
    }
    if symbols {
        charsets.push(SYMBOLS);
    }

    if charsets.is_empty() {
        return Err(PasswordError::NoCharacterSetsEnabled);
    }

    Ok(charsets)
}

/// Build the character pool from the enabled character sets.
fn build_char_pool(
    uppercase: bool,
    lowercase: bool,
    digits: bool,
    symbols: bool,
) -> Result<Vec<u8>, PasswordError> {
    let mut pool = Vec::with_capacity(
        if lowercase { LOWERCASE.len() } else { 0 }
            + if uppercase { UPPERCASE.len() } else { 0 }
            + if digits { DIGITS.len() } else { 0 }
            + if symbols { SYMBOLS.len() } else { 0 },
    );

    if lowercase {
        pool.extend_from_slice(LOWERCASE);
    }
    if uppercase {
        pool.extend_from_slice(UPPERCASE);
    }
    if digits {
        pool.extend_from_slice(DIGITS);
    }
    if symbols {
        pool.extend_from_slice(SYMBOLS);
    }

    if pool.is_empty() {
        return Err(PasswordError::NoCharacterSetsEnabled);
    }

    Ok(pool)
}

/// Generate a password with guaranteed representation from each charset.
#[inline]
fn generate_password_with_guarantee(
    rng: &mut ForgeryRng,
    length: usize,
    pool: &[u8],
    charsets: &[&[u8]],
) -> String {
    let mut chars: Vec<u8> = Vec::with_capacity(length);

    // First, add one character from each required charset
    for charset in charsets {
        chars.push(*rng.choose(charset));
    }

    // Fill the remaining length with random characters from the pool
    for _ in charsets.len()..length {
        chars.push(*rng.choose(pool));
    }

    // Shuffle the characters using Fisher-Yates
    for i in (1..chars.len()).rev() {
        let j = rng.gen_range(0, i);
        chars.swap(i, j);
    }

    // Convert to String (safe because all chars are ASCII)
    chars.into_iter().map(|c| c as char).collect()
}

/// Errors that can occur during password generation.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum PasswordError {
    /// No character sets were enabled.
    NoCharacterSetsEnabled,
    /// Password length is too short to include all required character sets.
    LengthTooShort {
        /// Requested password length.
        length: usize,
        /// Minimum required length (number of enabled character sets).
        required: usize,
    },
}

impl std::fmt::Display for PasswordError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::NoCharacterSetsEnabled => {
                write!(f, "at least one character set must be enabled")
            }
            Self::LengthTooShort { length, required } => {
                write!(
                    f,
                    "password length {} is too short; need at least {} to include all character sets",
                    length, required
                )
            }
        }
    }
}

impl std::error::Error for PasswordError {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_passwords_count() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 100, 12, true, true, true, true).unwrap();
        assert_eq!(passwords.len(), 100);
    }

    #[test]
    fn test_password_length() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        for length in [8, 12, 16, 24, 32, 64] {
            let passwords =
                generate_passwords(&mut rng, 10, length, true, true, true, true).unwrap();
            for password in &passwords {
                assert_eq!(
                    password.len(),
                    length,
                    "Password should have length {}",
                    length
                );
            }
        }
    }

    #[test]
    fn test_password_lowercase_only() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 100, 20, false, true, false, false).unwrap();
        for password in &passwords {
            for c in password.chars() {
                assert!(
                    c.is_ascii_lowercase(),
                    "Should only contain lowercase: {}",
                    password
                );
            }
        }
    }

    #[test]
    fn test_password_uppercase_only() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 100, 20, true, false, false, false).unwrap();
        for password in &passwords {
            for c in password.chars() {
                assert!(
                    c.is_ascii_uppercase(),
                    "Should only contain uppercase: {}",
                    password
                );
            }
        }
    }

    #[test]
    fn test_password_digits_only() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 100, 20, false, false, true, false).unwrap();
        for password in &passwords {
            for c in password.chars() {
                assert!(
                    c.is_ascii_digit(),
                    "Should only contain digits: {}",
                    password
                );
            }
        }
    }

    #[test]
    fn test_password_symbols_only() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 100, 20, false, false, false, true).unwrap();
        for password in &passwords {
            for c in password.chars() {
                assert!(
                    SYMBOLS.contains(&(c as u8)),
                    "Should only contain symbols: {}",
                    password
                );
            }
        }
    }

    #[test]
    fn test_password_no_charsets_error() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let result = generate_passwords(&mut rng, 10, 12, false, false, false, false);
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), PasswordError::NoCharacterSetsEnabled);
    }

    #[test]
    fn test_password_guarantees_all_charsets() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        // Generate many passwords with all charsets and verify each has at least one from each
        let passwords = generate_passwords(&mut rng, 100, 12, true, true, true, true).unwrap();

        for password in &passwords {
            let has_upper = password.chars().any(|c| c.is_ascii_uppercase());
            let has_lower = password.chars().any(|c| c.is_ascii_lowercase());
            let has_digit = password.chars().any(|c| c.is_ascii_digit());
            let has_symbol = password.chars().any(|c| SYMBOLS.contains(&(c as u8)));

            assert!(
                has_upper,
                "Password should contain uppercase: {}",
                password
            );
            assert!(
                has_lower,
                "Password should contain lowercase: {}",
                password
            );
            assert!(has_digit, "Password should contain digit: {}", password);
            assert!(has_symbol, "Password should contain symbol: {}", password);
        }
    }

    #[test]
    fn test_password_deterministic() {
        let mut rng1 = ForgeryRng::new();
        let mut rng2 = ForgeryRng::new();

        rng1.seed(12345);
        rng2.seed(12345);

        let passwords1 = generate_passwords(&mut rng1, 50, 16, true, true, true, true).unwrap();
        let passwords2 = generate_passwords(&mut rng2, 50, 16, true, true, true, true).unwrap();

        assert_eq!(passwords1, passwords2);
    }

    #[test]
    fn test_password_empty_batch() {
        let mut rng = ForgeryRng::new();
        let passwords = generate_passwords(&mut rng, 0, 12, true, true, true, true).unwrap();
        assert!(passwords.is_empty());
    }

    #[test]
    fn test_password_length_too_short() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        // Zero length with 4 charsets enabled should fail
        let result = generate_passwords(&mut rng, 10, 0, true, true, true, true);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            PasswordError::LengthTooShort {
                length: 0,
                required: 4
            }
        );

        // Length 3 with 4 charsets enabled should fail
        let result = generate_passwords(&mut rng, 10, 3, true, true, true, true);
        assert!(result.is_err());

        // Length 4 with 4 charsets enabled should succeed
        let result = generate_passwords(&mut rng, 10, 4, true, true, true, true);
        assert!(result.is_ok());

        // Length 1 with 1 charset should succeed
        let result = generate_passwords(&mut rng, 10, 1, false, true, false, false);
        assert!(result.is_ok());
    }

    #[test]
    fn test_single_password() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let password = generate_password(&mut rng, 16, true, true, true, true).unwrap();
        assert_eq!(password.len(), 16);
    }

    #[test]
    fn test_single_password_error() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let result = generate_password(&mut rng, 16, false, false, false, false);
        assert!(result.is_err());
    }

    #[test]
    fn test_different_seeds_different_results() {
        let mut rng1 = ForgeryRng::new();
        let mut rng2 = ForgeryRng::new();

        rng1.seed(1);
        rng2.seed(2);

        let passwords1 = generate_passwords(&mut rng1, 100, 16, true, true, true, true).unwrap();
        let passwords2 = generate_passwords(&mut rng2, 100, 16, true, true, true, true).unwrap();

        assert_ne!(
            passwords1, passwords2,
            "Different seeds should produce different passwords"
        );
    }

    #[test]
    fn test_password_mixed_charsets() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        // Generate enough passwords to statistically hit all character sets
        let passwords = generate_passwords(&mut rng, 100, 100, true, true, true, true).unwrap();

        let mut has_upper = false;
        let mut has_lower = false;
        let mut has_digit = false;
        let mut has_symbol = false;

        for password in &passwords {
            for c in password.chars() {
                if c.is_ascii_uppercase() {
                    has_upper = true;
                } else if c.is_ascii_lowercase() {
                    has_lower = true;
                } else if c.is_ascii_digit() {
                    has_digit = true;
                } else if SYMBOLS.contains(&(c as u8)) {
                    has_symbol = true;
                }
            }
        }

        assert!(has_upper, "Should contain uppercase letters");
        assert!(has_lower, "Should contain lowercase letters");
        assert!(has_digit, "Should contain digits");
        assert!(has_symbol, "Should contain symbols");
    }

    #[test]
    fn test_password_error_display() {
        let err = PasswordError::NoCharacterSetsEnabled;
        let msg = format!("{}", err);
        assert!(msg.contains("character set"));
    }

    #[test]
    fn test_all_lowercase_chars_reachable() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        // Generate enough passwords to statistically hit all 26 lowercase chars
        let passwords = generate_passwords(&mut rng, 1000, 50, false, true, false, false).unwrap();
        let mut seen = std::collections::HashSet::new();

        for password in &passwords {
            for c in password.chars() {
                seen.insert(c);
            }
        }

        // Should have seen all 26 lowercase letters
        assert_eq!(
            seen.len(),
            26,
            "Should see all 26 lowercase letters, but only saw {} chars: {:?}",
            seen.len(),
            seen
        );
    }

    #[test]
    fn test_all_uppercase_chars_reachable() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 1000, 50, true, false, false, false).unwrap();
        let mut seen = std::collections::HashSet::new();

        for password in &passwords {
            for c in password.chars() {
                seen.insert(c);
            }
        }

        assert_eq!(
            seen.len(),
            26,
            "Should see all 26 uppercase letters, but only saw {} chars: {:?}",
            seen.len(),
            seen
        );
    }

    #[test]
    fn test_all_digit_chars_reachable() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 1000, 50, false, false, true, false).unwrap();
        let mut seen = std::collections::HashSet::new();

        for password in &passwords {
            for c in password.chars() {
                seen.insert(c);
            }
        }

        assert_eq!(
            seen.len(),
            10,
            "Should see all 10 digits, but only saw {} chars: {:?}",
            seen.len(),
            seen
        );
    }

    #[test]
    fn test_all_symbol_chars_reachable() {
        let mut rng = ForgeryRng::new();
        rng.seed(42);

        let passwords = generate_passwords(&mut rng, 1000, 50, false, false, false, true).unwrap();
        let mut seen = std::collections::HashSet::new();

        for password in &passwords {
            for c in password.chars() {
                seen.insert(c);
            }
        }

        assert_eq!(
            seen.len(),
            SYMBOLS.len(),
            "Should see all {} symbols, but only saw {} chars: {:?}",
            SYMBOLS.len(),
            seen.len(),
            seen
        );
    }
}

#[cfg(test)]
mod proptest_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        /// Property: batch size is always respected
        #[test]
        fn prop_batch_size_respected(n in 0usize..500) {
            let mut rng = ForgeryRng::new();
            rng.seed(42);

            let passwords = generate_passwords(&mut rng, n, 12, true, true, true, true).unwrap();
            prop_assert_eq!(passwords.len(), n);
        }

        /// Property: all passwords have the specified length
        /// Note: length must be at least 4 when all 4 charsets are enabled
        #[test]
        fn prop_password_length(length in 4usize..100, n in 1usize..50) {
            let mut rng = ForgeryRng::new();
            rng.seed(42);

            let passwords = generate_passwords(&mut rng, n, length, true, true, true, true).unwrap();
            for password in passwords {
                prop_assert_eq!(password.len(), length);
            }
        }

        /// Property: same seed produces same output
        #[test]
        fn prop_seed_determinism(seed_val in any::<u64>(), n in 1usize..50) {
            let mut rng1 = ForgeryRng::new();
            let mut rng2 = ForgeryRng::new();

            rng1.seed(seed_val);
            rng2.seed(seed_val);

            let passwords1 = generate_passwords(&mut rng1, n, 16, true, true, true, true).unwrap();
            let passwords2 = generate_passwords(&mut rng2, n, 16, true, true, true, true).unwrap();

            prop_assert_eq!(passwords1, passwords2);
        }

        /// Property: lowercase-only passwords contain only lowercase
        #[test]
        fn prop_lowercase_only(n in 1usize..50) {
            let mut rng = ForgeryRng::new();
            rng.seed(42);

            let passwords = generate_passwords(&mut rng, n, 20, false, true, false, false).unwrap();
            for password in passwords {
                for c in password.chars() {
                    prop_assert!(c.is_ascii_lowercase());
                }
            }
        }

        /// Property: digits-only passwords contain only digits
        #[test]
        fn prop_digits_only(n in 1usize..50) {
            let mut rng = ForgeryRng::new();
            rng.seed(42);

            let passwords = generate_passwords(&mut rng, n, 20, false, false, true, false).unwrap();
            for password in passwords {
                for c in password.chars() {
                    prop_assert!(c.is_ascii_digit());
                }
            }
        }
    }
}
